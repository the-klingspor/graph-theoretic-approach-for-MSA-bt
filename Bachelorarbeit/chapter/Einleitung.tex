\chapter{Einleitung und Motivation}
\label{ch:einleitung}

Das berechnen von multiplen \emph{Sequenzalignments} ist eine fundamentale Technik, die eine Vielzahl von Anwendungsgebieten in der Biologie, aber auch in anderen Disziplinen wie dem \emph{Natural Language Processing} hat. Wir werden im Laufe dieses Kapitels zunächst etwas darüber kennenlernen was \emph{Alignments} eigentlich sind  und wo ihre Hauptanwendungsgebiete liegen. Dann führen wir mit dem Algorithmus von Needleman-Wunsch einen Standardansatz für paarweise \emph{Alignments} ein. Am Beispiel dieses Algorithmus beschäftigen wir uns mit der Komplexität des \emph{multiple sequence Alignment}-Problems und stellen fest, dass es für Zuweisungen zwischen mehr als nur einigen wenigen Sequenzen nicht zielführend ist diese mathematisch exakt zu berechnen. Um diesem Problem Herr zu werden, lernen wir im Laufe der Bachelorarbeit zwei ausgefeilte Heuristiken für multiple \emph{Sequenzalignments} ein. Zunächst lernen wir DIALIGN kennen, einen Algorithmus, der anders als Needleman-Wunsch nicht auf der Basis von einzelnen Symbolen \emph{Alignments} konstruiert \citep{mdw96}. Stattdessen werden ganze Segmente als Bausteine der Zuweisungen benutzt. Der zweite Algorithmus ist der graphtheoretische Ansatz von \cite{cpm10}. Dieser basiert zwar auch auf DIALIGN, hat aber den Anspruch für Situationen bei denen die Heuristik von DIALIGN falsche Entscheidungen trifft, bessere Ergebnisse zu liefern. Exemplarisch wird danach ein wichtiger Schritt des Verfahrens programmatisch umgesetzt. Dabei wird mit der Programmiersprache C++ und der \enquote{Boost Graph Library} gearbeitet.

\section{Einführung und Anwendungsgebiete}

Ziel von \emph{Sequenzalignments} ist es für eine Menge von Zeichenketten aus einem endlichen Alphabet Zuordnungen zwischen den einzelnen Symbolen zu finden, sodass möglichst ähnliche einzelne Symbole oder ganze Abschnitte einander zugeordnet sind. Man versucht auf diese Weise funktionelle, strukturelle oder evolutionäre Ähnlichkeiten zu finden. Ein Beispiel für relevante strukturelle Ähnlichkeiten sind Proteinsequenzen. Wenn Proteine aus ähnlichen Aminosäuren in vergleichbaren Reihenfolgen aufgebaut sind, dann kann man davon ausgehen, dass diese auch eine ähnliche 3D-Struktur und ähnliche Funktionen haben, selbst wenn sie in unterschiedlichen Organismen vorkommen. Im Laufe der Evolution verändern sich aufgrund von Mutationen die DNA und die Proteine von Arten. Diese Vorgänge sind die Ursache für den beispiellosen Reichtum an Lebewesen auf der Welt und mit Hilfe von \emph{Sequenzalignments} kann man nachvollziehen wie diese Entwicklung vonstatten gegangen ist. Zu den häufigsten Mutationsarten bei Genmutationen (im Gegensatz zu Genommutationen und Chromosomenmuationen) gehören Punktmutationen, bei denen eine einzelne DNA-Base durch eine andere ersetzt wird, sowie Deletionen und Insertionen, bei denen ganze Abschnitte einer Sequenz gelöscht oder eingefügt wurden. Glücklicherweise haben unsere \emph{Alignments} Möglichkeiten genau diese Situationen abzubilden. Informell könnte man sagen, dass man bei einer Zuweisung die Elemente der Eingabestrings einander so zuordnet, dass jedem Symbol genau ein Symbol jeder anderen Sequenz oder eine neu eingefügte Lücke, Gap genannt, zugeordnet ist. Dabei darf die Reihenfolge der Elemente nicht verändert werden.

Betrachten wir dazu zwei kleine Beispiele von Wörtern, die häufig falsch geschrieben werden:

\ttfamily
\begin{center}
\begin{tabular}{ccc}
		OR-GINAL & \hspace{2cm} & SYLVESTER \\
		ORIGINAL & \hspace{2cm} & SILVESTER
\end{tabular}
\end{center}
\normalfont

Im ersten Fall wurde bei der falschen Schreibweise ein benötigter Buchstabe weggelassen. Damit es trotzdem zu einer passenden Zuordnung der anderen Buchstaben kommt, wurde in die erste Sequenz eine Lücke (-) eingefügt. Im evolutionären Kontext wäre dies ein Beispiel für eine Deletion. Im zweiten Beispiel wurde ein Buchstabe durch einen anderen, fehlerhaften ersetzt. Das ist ein klassisches Beispiel für eine Punktmutation oder einen Einzelnukleotid-Polymorphismus.

Die Berechnung eines \emph{Sequenzalignments} ist in vielen Fällen der erste Schritt einer \emph{Sequenzanalyse} in der Molekularbiologie \cite{cpm10}. Diese Analysen dienen unter anderem dazu zu bestimmen, ob Sequenzen miteinander verwandt sind (\emph{Homologie}), zum Bestimmen von Markergenen oder um direkt von der Sequenz auf die molekulare Struktur zu schließen. 

Ein zweites großes Einsatzgebiet des \emph{multiple sequence Alignment}-Problems ist das \emph{Natural Language Processing}, also der maschinellen Verarbeitung menschlicher Sprache \citep{s10}. Sätze, Wörter oder Ausdrücke können aligniert werden, um mechanisch Sätze zu übersetzen oder Texte zusammenzufassen. Noch einen Schritt weiter geht das alignieren von \emph{Phonemen}, wo es beispielsweise darum geht von der textuellen Darstellung auf die Aussprache zu schließen oder andersrum Sprache textuell darzustellen. Obwohl viele dieser Anwendungen nur auf zwei Sequenzen arbeiten, wie beispielsweise einen Text und seiner Übersetzung, gibt es auch Fälle bei denen multiple \emph{Alignments} nötig sind. Dazu gehören unter anderem Vergleiche von Texten, die in anderen Worten den selben Inhalt wiedergeben, oder von gleichbedeutenden Worten aus unterschiedlichen Sprachen der selben Sprachfamilie. Bei der Sprachentwicklung gibt es interessante Parallelen zu den evolutionären Vorgängen in Genomen. Im Kontext dieser Bachelorarbeit werden wir uns jedoch im Folgenden auf Anwendungen in der molekularen Bioinformatik beschränken.  

\section{Der Algorithmus von Needleman-Wunsch}

Einer der ersten Algorithmen zur Berechnung von paarweisen \emph{Alignments} war der von \cite{nw70}. Dieser weist Zuweisungen auf Symbolebene zwischen zwei Sequenzen Werte zu und das Ziel ist es mit Hilfe von dynamischer Programmierung die Summe dieser Werte zu maximieren. Wir werden in den nächsten Abschnitten zunächst das Paradigma der dynamischen Programmierung kennenlernen, bevor wir es beim Algorithmus von Needleman-Wunsch benutzen. Unter Verwendung des Algorithmus lässt sich danach die Komplexität des \emph{multiple sequence Alignment}-Problems verdeutlichen, die uns den Anlass gibt in den nächsten Kapiteln zwei leistungsstarke Heuristiken zu betrachten.

\subsection{Dynamische Programmierung}

Die dynamische Programmierung ist ein Prinzip zum algorithmischen Lösen eines Optimierungsproblems. Dazu wird ein größeres Problem unter Zuhilfenahme der Lösungen von sich überschneidenden Teilproblemen gelöst, wobei die zuvor berechneten Lösungen gespeichert werden. Durch die Wiederverwendung der bereits gelösten Teilprobleme lässt sich auf diese Weise die oft exponentielle Laufzeit eines naiven Algorithmus auf polynomielle Laufzeit verringern. Dabei muss man beachten, ob es für den jeweiligen Kontext angemessen ist den höheren Speicherbedarf aufgrund der zu speichernden Werte für die verbesserte Laufzeit in Kauf zu nehmen. Oft wird die dynamische Programmierung mit dem \emph{divide and conquer}-Prinzip verwechselt. Beide Paradigmen darauf basieren ein Problem in kleinere Teilprobleme zu zerlegen. Der Hauptunterschied zwischen ihnen ist, dass das Problem bei \emph{divide and conquer} in disjunkte Teilprobleme zerlegt wird, statt in sich überlappende. Denken wir beispielsweise an Mergesort zurück: hier sortiere ich ein Feld, indem ich immer größer werdende disjunkte Teilfelder miteinander verschmelze.

In der Regel stellt man bei der dynamischen Programmierung zunächst eine Rekursionsgleichung auf mit deren Hilfe sich das Problem beschreiben lässt. Im Gegensatz zur \emph{Memoisation} wird diese Rekursionsgleichung jedoch nicht direkt und \emph{top-down} umgesetzt. Stattdessen werden \emph{bottom-up} zunächst die Basisfälle berechnet und darauf aufbauend immer größere Teilprobleme gelöst. Die Berechnung erfolgt dabei aber nichtsdestoweniger der Rekursionsformel entsprechend.

\subsection{Der Algorithmus}

\section{Komplexität}