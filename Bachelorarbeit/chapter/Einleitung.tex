\chapter{Einleitung und Motivation}
\label{ch:einleitung}

Das berechnen von multiplen \emph{Sequenzalignments} ist eine fundamentale Technik, die eine Vielzahl von Anwendungsgebieten in der Biologie, aber auch in anderen Disziplinen wie dem \emph{Natural Language Processing} hat. Wir werden im Laufe dieses Kapitels zunächst etwas darüber kennenlernen was \emph{Alignments} eigentlich sind  und wo ihre Hauptanwendungsgebiete liegen. Dann führen wir mit dem Algorithmus von Needleman-Wunsch einen Standardansatz für paarweise \emph{Alignments} ein. Am Beispiel dieses Algorithmus beschäftigen wir uns mit der Komplexität des \emph{multiple sequence Alignment}-Problems und stellen fest, dass es für Zuweisungen zwischen mehr als nur einigen wenigen Sequenzen nicht zielführend ist diese mathematisch exakt zu berechnen. Um diesem Problem Herr zu werden, lernen wir im Laufe der Bachelorarbeit zwei ausgefeilte Heuristiken für multiple \emph{Sequenzalignments} ein. Zunächst lernen wir DIALIGN kennen, einen Algorithmus, der anders als Needleman-Wunsch nicht auf der Basis von einzelnen Symbolen \emph{Alignments} konstruiert \citep{mdw96}. Stattdessen werden ganze Segmente als Bausteine der Zuweisungen benutzt. Der zweite Algorithmus ist der graphtheoretische Ansatz von \cite{cpm10}. Dieser basiert zwar auch auf DIALIGN, hat aber den Anspruch für Situationen bei denen die Heuristik von DIALIGN falsche Entscheidungen trifft, bessere Ergebnisse zu liefern. Exemplarisch wird danach ein wichtiger Schritt des Verfahrens programmatisch umgesetzt. Dabei wird mit der Programmiersprache C++ und der \enquote{Boost Graph Library} gearbeitet.

\section{Einführung und Anwendungsgebiete}

Ziel von \emph{Sequenzalignments} ist es für eine Menge von Zeichenketten aus einem endlichen Alphabet Zuordnungen zwischen den einzelnen Symbolen zu finden, sodass möglichst ähnliche einzelne Symbole oder ganze Abschnitte einander zugeordnet sind. Man versucht auf diese Weise funktionelle, strukturelle oder evolutionäre Ähnlichkeiten zu finden. Ein Beispiel für relevante strukturelle Ähnlichkeiten sind Proteinsequenzen. Wenn Proteine aus ähnlichen Aminosäuren in vergleichbaren Reihenfolgen aufgebaut sind, dann kann man davon ausgehen, dass diese auch eine ähnliche 3D-Struktur und ähnliche Funktionen haben, selbst wenn sie in unterschiedlichen Organismen vorkommen. Im Laufe der Evolution verändern sich aufgrund von Mutationen die DNA und die Proteine von Arten. Diese Vorgänge sind die Ursache für den beispiellosen Reichtum an Lebewesen auf der Welt und mit Hilfe von \emph{Sequenzalignments} kann man nachvollziehen wie diese Entwicklung vonstatten gegangen ist. Zu den häufigsten Mutationsarten bei Genmutationen (im Gegensatz zu Genommutationen und Chromosomenmuationen) gehören Punktmutationen, bei denen eine einzelne DNA-Base durch eine andere ersetzt wird, sowie Deletionen und Insertionen, bei denen ganze Abschnitte einer Sequenz gelöscht oder eingefügt wurden. Glücklicherweise haben unsere \emph{Alignments} Möglichkeiten genau diese Situationen abzubilden. Informell könnte man sagen, dass man bei einer Zuweisung die Elemente der Eingabestrings einander so zuordnet, dass jedem Symbol genau ein Symbol jeder anderen Sequenz oder eine neu eingefügte Lücke, Gap genannt, zugeordnet ist. Dabei darf die Reihenfolge der Elemente nicht verändert werden.

Betrachten wir dazu zwei kleine Beispiele von Wörtern, die häufig falsch geschrieben werden:

\ttfamily
\begin{center}
\begin{tabular}{ccc}
		OR-GINAL & \hspace{2cm} & SYLVESTER \\
		ORIGINAL & \hspace{2cm} & SILVESTER
\end{tabular}
\end{center}
\normalfont

Im ersten Fall wurde bei der falschen Schreibweise ein benötigter Buchstabe weggelassen. Damit es trotzdem zu einer passenden Zuordnung der anderen Buchstaben kommt, wurde in die erste Sequenz eine Lücke (-) eingefügt. Im evolutionären Kontext wäre dies ein Beispiel für eine Deletion. Im zweiten Beispiel wurde ein Buchstabe durch einen anderen, fehlerhaften ersetzt. Das ist ein klassisches Beispiel für eine Punktmutation oder einen Einzelnukleotid-Polymorphismus.

Die Berechnung eines \emph{Sequenzalignments} ist in vielen Fällen der erste Schritt einer \emph{Sequenzanalyse} in der Molekularbiologie \cite{cpm10}. Diese Analysen dienen unter anderem dazu zu bestimmen, ob Sequenzen miteinander verwandt sind (\emph{Homologie}), zum Bestimmen von Markergenen oder um direkt von der Sequenz auf die molekulare Struktur zu schließen. 

Ein zweites großes Einsatzgebiet des \emph{multiple sequence Alignment}-Problems ist das \emph{Natural Language Processing}, also der maschinellen Verarbeitung menschlicher Sprache \citep{s10}. Sätze, Wörter oder Ausdrücke können aligniert werden, um mechanisch Sätze zu übersetzen oder Texte zusammenzufassen. Noch einen Schritt weiter geht das alignieren von \emph{Phonemen}, wo es beispielsweise darum geht von der textuellen Darstellung auf die Aussprache zu schließen oder andersrum Sprache textuell darzustellen. Obwohl viele dieser Anwendungen nur auf zwei Sequenzen arbeiten, wie beispielsweise einen Text und seiner Übersetzung, gibt es auch Fälle bei denen multiple \emph{Alignments} nötig sind. Dazu gehören unter anderem Vergleiche von Texten, die in anderen Worten den selben Inhalt wiedergeben, oder von gleichbedeutenden Worten aus unterschiedlichen Sprachen der selben Sprachfamilie. Bei der Sprachentwicklung gibt es interessante Parallelen zu den evolutionären Vorgängen in Genomen. Im Kontext dieser Bachelorarbeit werden wir uns jedoch im Folgenden auf Anwendungen in der molekularen Bioinformatik beschränken.  

\section{Der Algorithmus von Needleman-Wunsch}

Einer der ersten Algorithmen zur Berechnung von paarweisen \emph{Alignments} war der von \cite{nw70}. Dieser weist Zuweisungen auf Symbolebene zwischen zwei Sequenzen Werte zu und das Ziel ist es mit Hilfe von dynamischer Programmierung die Summe dieser Werte zu maximieren. Wir werden in den nächsten Abschnitten zunächst das Paradigma der dynamischen Programmierung kennenlernen, bevor wir es beim Algorithmus von Needleman-Wunsch benutzen. Unter Verwendung des Algorithmus lässt sich danach die Komplexität des \emph{multiple sequence Alignment}-Problems verdeutlichen, die uns den Anlass gibt in den nächsten Kapiteln zwei leistungsstarke Heuristiken zu betrachten.

\subsection{Dynamische Programmierung}

Die dynamische Programmierung ist ein Prinzip zum algorithmischen Lösen eines Optimierungsproblems. Dazu wird ein größeres Problem unter Zuhilfenahme der Lösungen von sich überschneidenden Teilproblemen gelöst, wobei die zuvor berechneten Lösungen in einer Tabelle gespeichert werden. Durch die Wiederverwendung der bereits gelösten Teilprobleme lässt sich auf diese Weise die oft exponentielle Laufzeit eines naiven Algorithmus auf polynomielle Laufzeit verringern. Dabei muss man beachten, ob es für den jeweiligen Kontext angemessen ist den höheren Speicherbedarf aufgrund der zu speichernden Werte für die verbesserte Laufzeit in Kauf zu nehmen. Oft wird die dynamische Programmierung mit dem \emph{divide and conquer}-Prinzip verwechselt. Beide Paradigmen darauf basieren ein Problem in kleinere Teilprobleme zu zerlegen. Der Hauptunterschied zwischen ihnen ist, dass das Problem bei \emph{divide and conquer} in disjunkte Teilprobleme zerlegt wird, statt in sich überlappende \citep{clrs09}. Denken wir beispielsweise an Mergesort zurück: hier sortiere ich ein Feld, indem ich immer größer werdende disjunkte Teilfelder miteinander verschmelze.

In der Regel stellt man bei der dynamischen Programmierung zunächst eine Rekursionsgleichung auf mit deren Hilfe sich das Problem beschreiben lässt. Im Gegensatz zur \emph{Memoisation} wird diese Rekursionsgleichung jedoch nicht direkt und \emph{top-down} umgesetzt. Stattdessen werden \emph{bottom-up} zunächst die Basisfälle berechnet und darauf aufbauend immer größere Teilprobleme gelöst. Die Berechnung erfolgt dabei aber nichtsdestoweniger der Rekursionsformel entsprechend. Aufgrund der direkten Umsetzung der Rekursionsgleichung sind die Korrektheitsbeweise der Algorithmen der dynamischen Programmierung oft sehr einfach und aus der Korrektheit der Formel folgt meistens automatisch die des ganzen Algorithmus.

Dynamische Programmierung wurde in den 1940er-Jahren von Richard Bellman in Stanford und später bei der Denkfabrik RAND Corporation entwickelt. Nach ihm ist auch das \emph{Bellmannsche Optimalitätsprinzip} benannt, das besagt, dass man bei vielen Optimierungsproblemen die optimalen Lösungen von Teilproblemen benutzen kann, um die optimale Lösung des eigentlichen Problems zu berechnen. Warum Bellman den Begriff \enquote{dynamische Programmierung} gewählt hat, ist unklar. In seiner Autobiographie \enquote{Eye of the Hurricane} erklärt er \citep{b84}:

\begin{quotation}
	An interesting question is, Where did the name, dynamic programming, come from? The 1950s were not good years for mathematical research. We had a very interesting gentleman in Washington named Wilson. He was Secretary of Defense, and he actually had a pathological fear and hatred of the word research. I’m not using the term lightly; I’m using it precisely. His face would suffuse, he would turn red, and he would get violent if people used the term research in his presence. You can imagine how he felt, then, about the term mathematical. The RAND Corporation was employed by the Air Force, and the Air Force had Wilson as its boss, essentially. Hence, I felt I had to do something to shield Wilson and the Air Force from the fact that I was really doing mathematics inside the RAND Corporation. What title, what name, could I choose? In the first place I was interested in planning, in decision making, in thinking. But planning, is not a good word for various reasons. I decided therefore to use the word “programming”. I wanted to get across the idea that this was dynamic, this was multistage, this was time-varying. I thought, let's kill two birds with one stone. Let's take a word that has an absolutely precise meaning, namely dynamic, in the classical physical sense. It also has a very interesting property as an adjective, and that is it's impossible to use the word dynamic in a pejorative sense. Try thinking of some combination that will possibly give it a pejorative meaning. It's impossible. Thus, I thought dynamic programming was a good name. It was something not even a Congressman could object to. So I used it as an umbrella for my activities.
\end{quotation}

Ob diese Geschichte wirklich war ist, ist fraglich, denn die erste Arbeit Bellmans, die den Begriff benutzt, wurde bereits 1952 veröffentlicht, obwohl der oben genannte Charles Wilson erst ein Jahr später Verteidigungsminister wurde. Anderen Aussagen zufolge wurde der Begriff analog zur linearen Programmierung von George Dantzig gewählt, dem Erfinder des Simplex-Verfahrens \citep{rn09}. Dieser war ungefähr zur selben Zeit bei RAND beschäftigt. Das Adjektiv \enquote{dynamisch} bezieht sich dabei auf die künstliche Einfügung von Zeit in ein statisches Problem \citep{b57}. Genauer gesagt ist damit gemeint, dass die Reihenfolge der Durchführung von Berechnungen von Bedeutung ist: zunächst müssen die optimalen Lösungen der sich überlappenden Teilprobleme berechnet werden, bevor ich diese zur optimalen Lösung des eigentlichen Problems zusammensetzen kann.

\subsection{Der Algorithmus}

Der Algorithmus von Needleman-Wunsch ist ein \emph{Alignierer} auf der Basis von einzelnen Symbolen \citep{nw70}. Da dieses Kapitel einen eher motivierenden Charakter hat, werden wir den Algorithmus auf einer etwas informaleren Ebene betrachten. Zunächst lernen wir dafür eine etwas einfachere Definition eines \emph{Alignments} kennenlernen, die wir im nächsten Kapitel durch eine komplexere, aber äquivalente ergänzen, die sich insbesondere auch für multiple eignet, die aus mehr als zwei Sequenzen bestehen.

\begin{definition}[Alignment (NW)]
	Seien $S_1[1,\dots, n]$ und $S_2[1,\dots,m]$ zwei Zeichenketten über einem endlichen Alphabet. Eine Relation $\mathcal{R}$ zwischen Symbolen dieser beiden Sequenzen ist genau dann ein \emph{Alignment}, wenn für alle Paare von Zweiertupeln $S_1[i],S_2[j]$ und $S_1[i'],S_2[j']$ aus $\mathcal{R}$ gilt, dass aus $i < i'$ auch $j < j'$ folgt. Mit anderen Worten: es gibt keine überkreuzten Zuweisungen.
\end{definition}

Unser Ziel ist es jetzt aus allen möglichen \emph{Alignments} von $S_1$ und $S_2$ das beste zu finden. Dazu brauchen wir eine Möglichkeit die Güte von \emph{Alignments} zu vergleichen. Wenn zwei Symbole $s = S_1[i]$ und $s' = S_2[j]$ einander zugewiesen werden, dann weisen wir diesen ein Gewicht $\alpha_{s,t}$ zu, abhängig von der Ähnlichkeit der beiden Symbole. Oft wird hier nur zwischen Übereinstimmungen und Abweichungen unterschieden, aber in manchen Kontexten wie beispielsweise Proteinsequenzen mag es auch andere Möglichkeiten geben. Genauer widmen wir uns diesem Thema in Abschnitt \ref{subsec:subs_matr}. Wird hingegen eine Lücke in eine der beiden Sequenzen eingefügt, dann ziehen wir dann Kosten in der Höhe $\delta$ ab (sog. \emph{Gap Penalty}).

\begin{definition}{Score (NW)}
	Gegeben seien zwei Sequenzen $S_1$ und $S_2$ und ein \emph{Alignment} $\mathcal{R}$, sowie die \emph{Ähnlichkeitswerte} $\alpha$ und  der \emph{Gap Penalty} $\delta$. Dann definieren wir:
	
	\begin{equation}
		score(\mathcal{R},S_1,S_2) \coloneqq \sum_{(s,t)\in \mathcal{R}}{\alpha_{s,t}} - \sum_{s : \nexists t : (s,t)\in \mathcal{R}}{\delta} - \sum_{t : \nexists s : (s,t)\in \mathcal{R}}{\delta}
	\end{equation}
\end{definition}

Der \emph{Score} ist für ein \emph{Alignment} beim Algorithmus von Needleman-Wunsch also als die Summe aller \emph{Ähnlichkeitswerte} von einander zugewiesenen Symbolen der beiden Sequenzen definiert, von denen die \emph{Gap Penalties} aller eingefügten Lücken abgezogen werden. Das Ziel wird es jetzt sein eine Rekursionsgleichung aufzustellen mit deren Hilfe man diesen \emph{Score} maximieren kann. 

\section{Komplexität}